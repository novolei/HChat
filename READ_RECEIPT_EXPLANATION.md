# 📬 已读回执逻辑说明

## 🎯 你的问题

> 如果当前用户发送消息给别的用户，别的用户的 App 在后台的时候，消息发送出去了，这时当前用户发送的消息的已读状态是已读呢还是未读？

## ✅ 答案：**未读**

当前的已读回执系统遵循以下逻辑：

### 📊 消息状态流转

```
发送消息
    ↓
status = .sending (📤 发送中)
    ↓
收到服务器 ACK
    ↓
status = .sent (✓ 已送达服务器)
    ↓
其他用户的 App 在前台，看到消息
    ↓
其他用户的 App 发送已读回执
    ↓
收到已读回执
    ↓
status = .read (✓✓ 已读)
```

### 🔍 当前实现分析

#### 1. 发送消息时的初始状态

查看代码，消息发送时的状态是 `.sending`，收到服务器 ACK 后变为 `.sent`。

#### 2. 已读回执的发送条件（ReadReceiptManager.swift 第 43-54 行）

```swift
func markVisibleMessagesAsRead(messages: [ChatMessage]) {
    for message in messages {
        // 只标记别人发送的消息
        guard message.sender != client.myNick else { continue }
        
        markAsRead(messageId: message.id, channel: message.channel)
    }
}
```

**关键点**：
- ✅ 只有**看到消息**的用户才会发送已读回执
- ✅ 只标记**别人发送**的消息
- ✅ 需要 App **在前台运行**

#### 3. 已读回执的接收处理（ReadReceiptManager.swift 第 85-88 行）

```swift
// 如果是自己发送的消息，更新状态为已读
if message.sender == client?.myNick {
    message.status = .read
}
```

**关键点**：
- ✅ 只有收到**其他用户的已读回执**后，才会将自己的消息标记为 `.read`

### 🎬 实际场景分析

#### 场景 1：对方 App 在后台

```
你发送消息 → status = .sending
    ↓
服务器收到 → status = .sent
    ↓
对方 App 在后台 → WebSocket 连接被挂起
    ↓
对方收不到消息 → ❌ 不会发送已读回执
    ↓
你的消息状态 → 保持 .sent（未读）✓
```

**结果**：你的消息显示为 **✓ 已送达**（单勾），**不是已读**。

#### 场景 2：对方 App 在前台

```
你发送消息 → status = .sending
    ↓
服务器收到 → status = .sent
    ↓
对方 App 在前台 → 收到消息
    ↓
对方 App 看到消息 → 发送已读回执
    ↓
你收到已读回执 → status = .read
    ↓
你的消息状态 → ✓✓ 已读
```

**结果**：你的消息显示为 **✓✓ 已读**（双勾，蓝色）。

#### 场景 3：对方 App 从后台切回前台

```
你发送消息 → status = .sent（对方在后台）
    ↓
对方切回前台 → App 重新连接
    ↓
对方收到消息 → 显示在聊天列表
    ↓
对方打开聊天 → markVisibleMessagesAsRead()
    ↓
对方发送已读回执
    ↓
你收到已读回执 → status = .read
    ↓
你的消息状态 → ✓✓ 已读
```

**结果**：延迟后变为已读。

### 📱 UI 显示

根据 `MessageStatus.swift`：

| 状态 | 图标 | 颜色 | 说明 |
|------|------|------|------|
| `.sending` | 🕐 clock | 灰色 | 发送中 |
| `.sent` | ✓ checkmark | 灰色 | 已送达服务器（单勾） |
| `.delivered` | ✓✓ checkmark.circle | 蓝色 | 已送达对方（双勾） |
| `.read` | ✓✓ checkmark.circle.fill | 蓝色 | 已读（双勾，填充） |
| `.failed` | ⚠️ triangle | 红色 | 发送失败 |

### ⚠️ 当前系统的限制

#### 1. 无 `.delivered` 状态

当前代码中，消息状态直接从 `.sent` 跳到 `.read`，**没有 `.delivered` 状态**。

这意味着：
- ❌ 无法区分"对方收到但未读"和"对方未收到"
- ✅ 只能区分"已读"和"未读"

#### 2. 依赖 App 前台运行

已读回执需要：
- ✅ 接收方 App 在前台运行
- ✅ 接收方打开了聊天界面
- ✅ 接收方看到了消息

如果：
- ❌ 接收方 App 在后台 → 不会发送已读回执
- ❌ 接收方 App 已关闭 → 不会发送已读回执
- ❌ 接收方在其他界面 → 不会发送已读回执

### 🔄 与其他 IM 的对比

#### WhatsApp / Telegram

```
单勾 (✓)   = 已送达服务器
双勾 (✓✓)  = 已送达对方设备
蓝色双勾   = 已读
```

#### 当前 HChat

```
单勾 (✓)   = 已送达服务器
（没有双勾表示送达设备）
蓝色双勾   = 已读
```

### 💡 建议改进（可选）

如果需要更完善的已读回执系统，可以：

#### 1. 添加 `.delivered` 状态

```swift
// 当对方 App 收到消息时（即使在后台）
客户端收到消息 → 发送 "delivered" 回执
发送方收到回执 → status = .delivered
```

#### 2. 后台也发送 delivered 回执

```swift
// 即使 App 在后台，也能通过 WebSocket 发送简单的回执
// 或者通过 APNs 的静默推送触发
```

#### 3. 区分"送达"和"已读"

```
✓    灰色单勾  = 已送达服务器
✓✓   灰色双勾  = 已送达对方设备
✓✓   蓝色双勾  = 已读
```

## 🎉 总结

**回答你的问题**：

当你发送消息时，如果对方的 App 在后台：

1. ✅ 你的消息**会发送成功**
2. ✅ 状态显示为 **✓ 已送达服务器**（单勾，灰色）
3. ❌ **不会**显示为已读（因为对方 App 在后台，收不到消息，也就不会发送已读回执）
4. ✅ 当对方切回前台并打开聊天时，才会发送已读回执
5. ✅ 此时你的消息状态才会变为 **✓✓ 已读**（双勾，蓝色）

**这是符合预期的行为**，与 WhatsApp、iMessage 等主流 IM 的逻辑一致！
